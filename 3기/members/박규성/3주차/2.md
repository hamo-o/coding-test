# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. cap : 트럭에 실을 수 있는 재활용 택배 상자의 최대 개수
2. n : 배달할 집의 개수
3. deliveries : 배달할 재활용 택배 상자의 개수를 담은 배열
4. pickups : 각 집에서 수거할 빈 재활용 택배 상자의 개수를 담은 배열

### 리턴값

- 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동거리

### 전제 조건

1. 트럭에는 최대 cap개 실을 수 있다.
2. 재활용 택배 상자를 실어 각 집에 배달하며, 빈 것을 수거해 물류창교에 내린다.
3. 모든 배달과, 모든 수거를 마쳐야 한다.

### 유추 결과

1. 간 만큼 돌아온다.
2. 그렇기에, 마지막에 간 것들에 * 2를 하면 된다.
3. 뒤의 요소부터 처리하는 것이 더 적절할 듯하다. 뒤의 요소부터 cap개씩 뺀다.

### 풀이 1

1. deliveries와 pickups 두 배열의 값이 모두 0이 될 때까지 반복문을 수행한다.
2. 반복문 내부에서는, 맨 뒤의 요소를 구해 cnt에 더한다. 그리고 맨 뒤에서부터 cap만큼 값을 뺀다.

### 우려사항

1. 시간초과에 걸리지 않을까?
    - 시간 복잡도 : O(n^2), n은 최대 10만. 10만 ^ 2 = 100억
    - 시간초과에 걸린다.

### 풀이 2

1. deliveries와 pickups를 뒤에서부터 순회한다.
2. cap을 계속 반복한다. 뒤에서부터 cap -> 0, cap -> 0을 반복한다. 이 때 시간 복잡도는 O(N)이다. cap이 시작하는 지점을 기록한다.
3. cap이 시작하는 지점의 두 배열(deliveries와 pickups)을 비교하여 더 큰 요소만큼 더한다.

### 예시

- 1번 예제
    1. [1,0,2,0,0] / [0,3,0,0,0] (5)
    2. [0,0,0,0,0] / [0,0,0,0,0] (3)
        - 결과 = (5 + 3) * 2 = 16
- 2번 예제
    1. [1,0,2,0,1,0,0] / [0,2,0,1,0,0,0] (7)
    2. [1,0,1,0,0,0,0] / [0,1,0,0,0,0,0] (5)
    3. [0,0,0,0,0,0,0] / [0,0,0,0,0,0,0] (3)
        - 결과 = (7 + 5 + 3) * 2 = 30

### 의문

1. 만약, [0,5,0],[0,0,5]처럼 수거해야할 게 더 뒤에 있을 때, 수거를 먼저할 수 있을까? 즉, 수거와 배달 최대 개수는 각각인가 ?
    
    => cap = 재활용 택배 상자의 최대 개수를 나타내는 정수이기 때문에, 빈 것이든 찬 것이든 상관 없을 거 같긴하다.
    
    근데, 이 케이스는 신경 안써도 되는 이유가, 위와 같은 경우 5개를 먼저 2번 째 집에서 주고 더 나아가서 수거해오면 되는 거다. 
    
    즉, 우리가 이런 먼저 수거, 먼저 배달은 신경 쓰지 않아도 된다는 말이다.
    

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/150369

# 2. 내 풀이

## 2-1. 알고리즘

## 2-2. 시간복잡도

## 2-3. 풀이

```jsx
function solution(cap, n, deliveries, pickups) {
    const getMoveArray = (array) => {
        let currentIndex = n - 1;
        const moveArray = [];
        while(1){
            if(currentIndex < 0) break;
            
            let maxCap = cap;
            while(1){
                if(maxCap === 0 || currentIndex < 0) break; // cap을 소진했거나, 현재 index값이 0보다 작다면 종료
                if(array[currentIndex] === 0){ // 0이라면, 패스
                    currentIndex--;
                }else{ // 0이 아니라면, 빼기
                    if(maxCap === cap) moveArray.push(currentIndex);
                    array[currentIndex]--;
                    maxCap--;
                }
            }
        }
        return moveArray;
    }
    
    const deliveryArray  = getMoveArray(deliveries);
    const pickupArray  = getMoveArray(pickups);
    
    const maxLength = Math.max(deliveryArray.length,pickupArray.length);
    let cnt = 0;
    for(let i=0;i<maxLength;i++){
        cnt += Math.max(deliveryArray[i] ?? 0,pickupArray[i] ?? 0) + 1;
    }
    return cnt * 2;
}
```

배달과 수거를 독립된 케이스로 생각했다. 왜냐하면 배달을 하러 가든, 수거를 하러 가든 결국 가야 하기 때문이다. 가는 길에 배달을 하고, 오는 길에 수거를 하면 된다. 그래서 우리가 포커스를 맞춰야 할 것은 얼마나 멀리 가느냐이다.

또한 수거하는 순서와 각 순서에 맞는 개수는 고려하지 않아도 된다. 왜냐하면 최대한 멀리 가는 것으로 설정하고, 마지막부터 놓고 오는 것이 최적이기 때문이다. 마지막 것을 처리하지 않으면, 나중에 다시 가야 하기 때문이다.

결론적으로, 가장 먼 곳을 먼저 다녀와야 하고, 배달과 수거는 독립적인 케이스라는 것을 생각해냈다.

deliveries와 pickups각 배열을 반복하고 순회하고, 뒤에서부터 빼는 방식을 택했다. 그리고 한 번 다녀올 때 최대로 배달 혹은 수거할 수 있는 개수가 cap이므로 반복문 안에서 cap만큼 순회를 진행한다.

1. deliveries와 pickups를 getMoveArray함수의 인자를 통해 전달한다.
2. getMoveArray함수를 실행한다.
    1. 처음 인덱스(currentIndex)는 n-1이다. 뒤에서부터 순회할 것이기 때문이다. 우리는 이 순회를, 배열의 모든 값이 0이 될 때까지 수행하면 된다.
    2. 모든 값이 0이 되어, currentIndex값이 0보다 작아질 때까지 순회한다.
    3. cap이 한 번에 배달 및 수거할 수 있는 최대 개수이므로, maxCap을 cap으로 설정하고 이 maxCap이 0이 될때까지 반복문을 수행한다. 이 반복문의 종료조건은 maxCap이 0이 되는 순간, 혹은 배달을 이미 마쳐 currentIndex가 0보다 작아진 순간이다.
    4. 각 반복문 안에서는, 현재 배열에서 currentIndex의 값이 0이라면 currentIndex를 1빼서 다음 집으로 넘어가고, currentIndex에서 값이 0보다 크다면 currentIndex을 뺀다.
    5. 그리고 maxCap만큼 순회를 마치면 array배열에 처음 array에 수정을 가한 값, 즉 처음 배달 위치를 기록한다.
3. 두 배열의 순회를 마쳤으면, 이제 두 배열의 각 요소들을 비교하며 더 큰값을 체크한다. 각 요소들은, 한 번 배달 및 수거를 가는 케이스들이다. 그리고 두 배열 중 더 큰 수를 구하는 이유는 더 멀리가는 것만 고려해야 하기 때문이다. 더 멀리 갔다는 것은, 더 가까운 곳에 가는 것도 커버한다.
4. 그리고, 마지막에 2배를 취해서, 가는 경우 + 오는 경우를 모두 고려한다.

### 나의 실수

1. deliveries와 pickups배열 두 개를 순회를 함께 하려고 했다.
    - 내 풀이에서 각각의 케이스는 독립 케이스이다. 그런데 한 while문 안에서 둘을 처리하려는 과정에서 많은 실수가 생겼고, 끝까지 풀지 못했다.
    - 위와 같은 풀이는, 나중에 함수화를 통해 각 케이스를 분리하려고했던 의도였다. 하지만, 이는 더 많은 실수를 유발했다.
    - 함수로 분리하여 푸니, 즉시 해결이 되었다. 각 케이스는 독립된 케이스가 되었고, 하나의 수정으로 두 케이스에 반영이 모두 되니 수정에도 매우 용이했다.
    
    > Action Items : 독립된 경우라면, 처음부터 함수로 분리하자. 실수를 매우 줄여주고, 수정에 매우 용이하다.
    >