# 1. 문제 파악

## 1-1. 주어진 정보

### 인자

1. n(number) : 거스름돈 금액 <= 10만
2. money(number[]) : 현재 보유하고 있는 돈의 종류, <= 100

### 리턴값

: n원을 거슬러줄 방법의 수

### 전제 조건

1. 1,000,000,007로 나눈 나머지를 리턴

### 우려사항

1. 순서는 고려하지 않는다. 즉, [1,2,2]와 [2,2,1]은 같은 경우이다.
2. 모든 경우의 수를 고려하면, 10억으로 나누라는 걸 봐서 .. 쉽지 않을 듯하다.
3. n은 최대 10만이기에 O(N^2)까지 경우가 증가해서는 안된다.

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/12907

# 2. 내 풀이

![alt text](image.png)

고민의 흔적,, 이렇게 3-4페이지 정도 작성하였다.

하지만 끝내 풀지못했다.

# 3. 다른 사람 풀이

```tsx
function solution (n, money){
    const MOD = 1_000_000_007;
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    
    for(let elem of money){
    	for(let i = elem; i < n+1; i++){
            dp[i] += dp[i-elem];
            dp[i] %= MOD;
        }
    }
    return dp[n];
}
```

동전을 기준으로 순회해야 하는 문제였다. 

1. 동전을 기준으로 순회한다.
    
    ```tsx
    for(let elem of money){
    	// ..
    }
    ```
    
2. 각 동전에서, 동전의 금액만큼 뺀 인덱스만큼 더해준다.
    
    ```tsx
    for(let elem of money){
    	for(let i = elem; i < n+1; i++){
        	dp[i] += dp[i-elem];
        }
    }
    ```
    

dp배열을 console에 찍어보면 다음과 같다.

```tsx
[ 1, 1, 1, 1, 1, 1 ]
[ 1, 1, 2, 2, 3, 3 ]
[ 1, 1, 2, 2, 3, 4 ]
```

각 동전 1,2,5를 순회할 때마다 console에 출력을 한 것이다. 

1원을 넣을 때는 1인덱스 전 요소에서 1원씩 더하면 된다.

2원을 넣을 때는 2인덱스 전 요소에서 2원씩 더하면 된다.

5원을 넣을 때는 5인덱스 전 요소에서 5원씩 더하면 된다.

근데, 1,2,5 순서대로 진행하지 않고 내가 처음 구상했던 것처럼 배열을 기준으로 앞에서부터 순차적으로 누적해나갈 경우, 중복되는 요소가 생기게 된다. 예를 들어 5원을 만든다고 할 때, 5는 4원에서 1원을 더한 것일 수도 있고, 3원에서 2원을 더한 것일 수도 있다. 앞에서부터 순차적으로 계산할 경우 중복이 생긴다. 

하지만 1,2,5순서대로 진행을 할 경우, 1원을 더할 때 모두 1원을 더해서 구성된 요소만 존재한다. 4에도 1이 존재하고, 여기서 1원을 더해 5에는 경우의 수 1이 더해진다. 

그리고 다음 순회에서 2원을 더하려 할 때, 기존 값들은 1원을 더해서 구성된 요소들이다. 3원에 2원을 더할 때, 3원 또한 1을 더해서 구성된 요소만 존재한다. 이 때, 4원에는 2원에서 2원을 더하여 1이 증가한다. 하지만, 5원은 4원에서 2를 더했을 때 해당하지 않기 때문에 5원에는 영향을 미치지 않는다.

즉, i원을 더해서 해당 값이 되는 경우, n-i원의 값에서만 영향을 미치게 된다. 

# 느낀 점

DP풀이를 생각했으나, 기준점이 달랐다. 나는 당연히 앞에서부터 순차적으로 더해나가야겠다고 생각했으나, 이렇게 풀 경우 앞에서 발생한 중복의 수를 계산할 수가 없었다.

올바른 풀이는 ‘돈’을 기준으로 순회하며 ‘돈’만큼 뺀 위치의 요소만큼 더해주는 것이었다.

같은 알고리즘에도 다양한 풀이가 있다는 것을 느꼈고, 다음에는 한 사고에만 갇히지 않고 더 멀리서 바라보도록 해야겠다.