# 1. 문제 파악

## 1-1. 주어진 정보

- `cap`: 트럭의 용적 (1~50)
- `n`: 집 개수 (1~10만)
- `deliveries`: 각 집마다 배달할 택배의 개수 (원소 1~50)
- `pickups`: 각 집마다 수거할 택배의 개수 (원소 1~50)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/150369

# 2. 내 풀이

## 2-1. 알고리즘

- 창고에서 먼 곳부터 배달, 수거를 진행. 먼 곳을 먼저 처리하는 것이 최소 거리이기 때문
- 필요한 최소 누적 용적을 배달 / 수거 각각 구함. 배달과 수거는 갈 때 / 올 때 따로 사용할 수 있으므로.
- 이러한 누적 합을 가장 먼 곳에서 0으로 돌아오면서 사용, 부족하다면 다시 더해가면서 거리를 구한다.
- 즉 그리디(먼 곳부터) + 누적 합

## 2-2. 시간복잡도

## 2-3. 풀이

```js
function solution(cap, n, deliveries, pickups) {
  let answer = 0;
  let sum_d = 0;
  let sum_p = 0;

  for (let i = n - 1; i >= 0; i--) {
    let count = 0;
    while (sum_d < deliveries[i] || sum_p < pickups[i]) {
      count++;
      sum_d += cap;
      sum_p += cap;
    }
    sum_d -= deliveries[i];
    sum_p -= pickups[i];

    answer += count * (i + 1) * 2;
  }
  return answer;
}
```

1. `sum_d`는 현재 배달에 사용할 수 있는 용적의 양. `sum_p`는 현재 수거에 사용할 수 있는 용적의 양.
2. 창고에서 가장 먼 인덱스 `(n-1)`부터 순회 시작
3. `count`는 왕복해야 할 횟수.
4. 배달 또는 수거 둘 중 하나의 용적이 부족하면 `cap`만큼 용적을 늘려주고 `count` 증가. 이때 동시에 늘려주는 이유는, 한 번 방문하면 배달 / 수거를 함께 진행할 수 있기 때문.
5. 사용할 만큼 용적이 늘어났으면, 해당 위치에서 용적을 사용. (누적 합에서 빼주기)
6. 해당 위치에서의 `count`만큼 왕복하여 거리 `answer`에 추가.
7. `i`를 줄여 더 가까운 인덱스에서 동일하게 진행. 아직 사용할 수 있는 용적이 남아있다면 `while`문 안으로 들어가지 않음. 이 경우는 더 먼 인덱스까지 왕복하며 해당 일을 함께 처리할 수 있다는 것을 의미한다. `while`문 안으로 들어가지 않으면 `count` 역시 0이므로 `answer`에 더해지지 않음.
8. 아직 사용할 수 있는 용적이 남아있지 않다면, 이전 인덱스의 왕복에서 해결되지 않았으므로 새롭게 용적을 늘려줘야 한다. (왕복 추가)
9. 모든 인덱스 순회 후 `answer` 반환
