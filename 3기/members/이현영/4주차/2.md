# 1. 문제 파악

## 1-1. 주어진 정보

- `routes`: [차량 진입지점, 차량 진출지점] 이 담겨 있는 차량 경로 배열 (1~10000)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/42884

# 2. 내 풀이

## 2-1. 알고리즘

- 처음에는 길이 60001 `count` 배열을 만들어, 모든 차의 경로를 체크하고, 다시 차들을 순회하면서 해당 차가 속한 가장 큰 `count`를 가진 곳에 카메라를 두는 식으로 생각을 했다. 하지만 길이 10000 배열에서, 각 차가 60000씩 순회한다면 10000\*60000으로 6초가 걸리며 시간제한에 따라 시간초과가 될 수 있다.
- 차들을 먼저 정렬하고, 순회하면서, 다음 차가 이전 차 범위에 속하는지 체크하며 카메라를 두는 형식으로 구현해보자.

## 2-2. 시간복잡도

`O(N)`

## 2-3. 풀이

```js
function solution(routes) {
  routes.sort((a, b) => a[1] - b[1]);

  let i = 0;
  let count = 0;
  while (i < routes.length) {
    const first_end = routes[i][1];
    while (i < routes.length && first_end >= routes[i][0]) i++;
    count++;
  }

  return count;
}
```

1. 경로를 **진출지점**을 기준으로 정렬한다. 진출지점으로 정렬하는 이유는, 더 작은 범위부터 시작하여 구간에 포함하는지 여부를 쉽게 판별할 수 있기 때문이다. (예를 들어, A, B, C 차가 있다고 했을 때 A에 B보다 큰 진출지점이 등장하면, B, C 모두 진입지점이 A의 진출지점 안쪽에 포함되지만 B가 너무 일찍 끝나버려 B, C 끼리 구간이 겹치지 않을 수 있다. 진입지점으로 정렬한다면 B, C가 모두 겹치는 구간이라고 파악하게 된다.)
2. 전체 차들을 순회한다.
3. 첫번째 차의 진출지점과, 이후 차들의 진입지점을 비교하여 이후 차가 포함되지 않을 때까지 `i`를 증가시킨다.
4. 포함되지 않는 차가 나타나면, `count`를 증가시키고 새로운 기준점을 잡는다.
5. 위 로직을 반복하다가 전체 차를 순회하면 종료하고 `count`를 반환한다.
