# 1. 문제 파악

## 1-1. 주어진 정보

- `targets`: 타겟의 위치를 `[s, e]`로 나타내는 배열 (길이 1~50만)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/181188

# 2. 내 풀이

## 2-1. 알고리즘

- 그리디. 저번 감시카메라? 문제와 같은 아이디어.

## 2-2. 시간복잡도

`O(N)`

## 2-3. 풀이

```js
function solution(targets) {
  const n = targets.length;
  targets.sort((a, b) => a[1] - b[1]);

  let [left, right, count] = [0, 0, 0];
  while (right < n) {
    const [s, e] = targets[left];
    right = left + 1;
    while (right < n && e > targets[right][0]) right++;

    left = right;
    count++;
  }

  return count;
}
```

1. 범위의 끝지점을 기준으로 정렬. 최솟값을 찾으려면 하나의 요격 당 최대의 미사일 범위를 커버해야 한다. 시작지점을 기준으로 정렬하면, 이미 미사일의 범위가 끝나버려서 요격 지점이 앞에 있는 미사일들을 커버하지 못할수도 있음.
2. `left`, `right`를 이용해서 커버 가능한 범위를 파악한다.
3. `right`가 범위 내에 있는 동안 순회. `right`의 시작점이 `left`의 끝점보다 작으면 범위에 포함되므로 `right`를 증가시킨다. 문제에서 같아지는 지점은 요격이 불가능하다 했으므로 `=`는 포함시키지 않는다.
4. 다음 범위를 시작하기 위해 `right`를 `left`에 할당한다.
5. 하나의 범위가 끝났으므로 `count++`
6. 반복이 종료되면 `count` 반환
