# 1. 문제 파악

## 1-1. 주어진 정보

- `numbers`: 연산해야 할 숫자 배열 (1~10만)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/77885

# 2. 내 풀이

## 2-1. 알고리즘

- 구현

## 2-2. 시간복잡도

## 2-3. 풀이

```js
function solution(numbers) {
  const answer = [];
  for (const number of numbers) {
    if (number % 4 === 3) answer.push(f(number));
    else answer.push(number + 1);
  }

  return answer;

  function f(n) {
    let current = n;
    let position = 0;

    while (current % 2 === 1) {
      current = Math.floor(current / 2);
      position++;
    }

    return n + 2 ** (position - 1);
  }
}
```

1. 대부분의 숫자는 그 다음 비트가 답이므로 1을 더해서 `answer`배열에 넣어준다.
2. 그러나 끝의 두 비트가 `11`이면 자릿수가 올라가면서 해당 비트 아래로 비트가 다 반전되어 버린다. `(011 -> 100)` 이는 4로 나눈 나머지가 3인 경우이다.
3. 이 경우 함수 `f`에서 처리해서 `answer`배열에 넣어준다.

   3-1. 이 경우 현재 숫자에서 1을 더하고, `(현재 자릿수 - 1)` 자리가 올라가기 직전 비트가 답이 된다. 그러면 올라간 두 자리를 제외한 비트들은 현재 숫자와 같아지기 때문.

   ex. `0111` -> 1 더하기 -> `1000` -> `(현재 자릿수 - 1)` 자리를 올리면 -> `1100` -> 그 직전 비트는? -> `1011`

   3-2. 맨 앞과 뒤에서 1을 더하고 빼는 과정을 거치므로 해당 과정을 제외하고 **[`(현재 자릿수 - 1)` 자리를 올리기]** 연산만 해주면 된다.

   3-3. 현재 숫자에 `2^(현재 자릿수 - 1)` 를 더한 숫자가 답이 된다.

4. `answer` 배열 반환
