# 1. 문제 파악

## 1-1. 주어진 정보

- `edges`: 그래프의 간선 `[a(진출), b(진입)]` 을 담은 배열 (길이 1~100만, 원소 1~100만)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/258711

# 2. 내 풀이

## 2-1. 알고리즘

## 2-2. 시간복잡도

## 2-3. 풀이

[1차풀이] (88점)

```js
function solution(edges) {
  const graph = {};
  let [vertex, donut, stick, eight, count] = [-1, 0, 0, 0, 0];

  for (const [a, b] of edges) {
    if (!graph[a]) graph[a] = [0, 0];
    if (!graph[b]) graph[b] = [0, 0];
    graph[a][0]++;
    graph[b][1]++;
  }

  for (const key in graph) {
    const [o, i] = graph[key];

    if (o === 0) stick += 1;
    else if (i >= 2 && o >= 2) eight += 1;

    if (o > count) {
      count = o;
      vertex = +key;
    }
  }

  donut = count - stick - eight;

  return [vertex, donut, stick, eight];
}
```

[2차풀이]

```js
function solution(edges) {
  const graph = {};
  let [vertex, donut, stick, eight, count] = [-1, 0, 0, 0, 0];

  for (const [a, b] of edges) {
    if (!graph[a]) graph[a] = [0, 0];
    if (!graph[b]) graph[b] = [0, 0];
    graph[a][0]++;
    graph[b][1]++;
  }

  for (const key in graph) {
    const [o, i] = graph[key];

    if (o === 0) stick += 1;
    else if (i >= 2 && o >= 2) eight += 1;

    if (i === 0 && o >= count) {
      count = o;
      vertex = +key;
    }
  }

  donut = count - stick - eight;

  return [vertex, donut, stick, eight];
}
```

1. 배열로 나타낸 그래프를 객체로 변환. 이때 `graph[a][0]`은 정점 `a`에서 나간 간선의 개수, `graph[a][1]`은 정점 `a`로 들어온 간선의 개수
2. 만든 그래프를 순회하며 나간 간선과 들어온 간선의 개수를 이용하여 어떤 그래프인지 파악한다.

   2-1. 막대그래프에는 나가는 간선이 없는 정점이 하나 존재한다.

   2-2. 8자그래프에는 들어오는 간선, 나가는 간선이 2개씩 있는 정점이 하나 존재한다. 이때 생성 정점인 `vertex`에서 들어오는 간선이 있을 수 있다.

   2-3. 들어오는 간선이 없고, 나가는 간선이 최대인 정점이 생성 정점이다. (그래프의 개수가 최소 2개이므로, 8자 그래프와 나가는 간선이 같아질수도 있는데 이 경우를 고려하지 않아 1차시도 실패)

3. 전체 그래프 개수에서 막대와 8자를 빼서 도넛 그래프의 개수를 구한다.
