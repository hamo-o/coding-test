# 1. 문제 파악

## 1-1. 주어진 정보

- `order`: 상자의 순서 배열 (길이 1~10만)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/131704

# 2. 내 풀이

## 2-1. 알고리즘

- 구현

## 2-2. 시간복잡도

## 2-3. 풀이

```js
function solution(order) {
  let want = 0;
  const sub = [];
  for (let cur = 1; cur <= order.length; cur++) {
    if (order[want] === cur) want++;
    else sub.push(cur);

    if (sub.length && order[want] === sub[sub.length - 1]) {
      sub.pop();
      want++;
    }
  }

  while (sub.length && order[want] === sub.pop()) want++;

  return want;
}
```

1. 기사님이 원하는 택배를 나타내는 `order[want]`, 보조 컨베이어 벨트 스택을 나타내는 `sub`
2. 메인 컨베이어 벨트에 `1~order.length` 까지의 상자가 순서대로 놓여있으므로 `for`문 순회, `cur`은 현재 처리해야 하는 상자
3. 현재 처리해야 하는 상자는 트럭에 싣거나, 보조 컨베이어 벨트로 보내거나 둘 중 하나의 경우만 가질 수 있다.
   3-1. 기사님이 원하는 택배면 트럭에 싣고, 다음 택배를 목표로 `want++`
   3-2. 그렇지 않으면 보조 컨베이어 벨트로 보낸다. 여전히 찾는 택배는 동일하다.
4. 보조 컨베이어 벨트의 맨 앞 상자가 요구하는 상자라면, 꺼내서 트럭에 싣고, 다음 택배를 목표로 `want++`
5. 메인 컨베이어 벨트의 상자를 다 처리한 후, 보조 컨베이어 벨트에 상자가 남아있다면, 원하는 택배인지 앞에서부터 확인하고 싣기를 반복한다.
6. 기사님이 원하는 택배를 어디까지 처리했는지 나타내는 `want`를 반환
