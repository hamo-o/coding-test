# 1. 문제 파악

## 1-1. 주어진 정보

- `n`: 초기 병사 명수 (1~10억)
- `k`: [무적권]을 써서 병사 소모 없이 라운드를 막을 수 있는 횟수 (1~50만)
- `enemy`: 매 라운드 적의 수를 담은 배열 (길이 100만, 원소 100만)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/142085

# 2. 내 풀이

## 2-1. 알고리즘

- 라운드 수가 최대 100만이므로 [무적권]을 사용할 라운드를 뽑는 경우의 수를 모두 구하는 것은 시간초과
- **그리디**
  - 적의 수가 많을수록 [무적권]을 쓰는 것이 유리하다.
  - 하지만 다수의 적이 뒤쪽에 몰려있어 [무적권]을 사용하지 못하게 된다면 이 역시 최선의 경우가 아니다.
  - 일단 [무적권]을 사용하지 않고 라운드를 계속 진행하다가, 병사가 모자라게 되면 그동안 진행한 라운드 중 가장 병사가 많은 라운드에서 [무적권]을 사용할 수 있도록 한다. -> 매 라운드마다 정렬 필요 -> 시간초과 -> 우선순위 큐 구현 필요..
- **이분탐색**
  - "통과 가능한 라운드의 수"를 가지고 체크한다.
  - 이러면 "라운드 수"가 고정인 상태로 통과가 가능한지 아닌지 판단할 수 있으므로, 해당 라운드까지의 정렬을 수행하면 된다.
  - 매 라운드마다 정렬(`N`\*`NlogN`)이 아닌 이분탐색으로 시간복잡도가 `logN`\*`NlogN`으로 줄었으므로 가능

## 2-2. 시간복잡도

## 2-3. 풀이

```js
function solution(n, k, enemy) {
  let left = 1;
  let right = enemy.length;
  const memo = enemy.reduce((acc, cur, i) => {
    const item = i > 0 ? cur + acc[i - 1] : cur;
    acc.push(item);
    return acc;
  }, []);

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (check(mid)) left = mid + 1;
    else right = mid - 1;
  }

  return left - 1;

  function check(round) {
    const stack = enemy.slice(0, round).sort((a, b) => a - b);
    let minus = 0;
    let skill = k;
    while (stack.length && skill--) minus += stack.pop();

    if (memo[round - 1] - minus <= n) return true;
    return false;
  }
}
```

1. `memo[i]`는 `i-1` 라운드까지 적의 수의 합이다. (이때 `push` 대신 전개 연산자 사용 시 시간초과 주의)
2. `left` -> 통과할 수 있는 라운드 + 1, `right` -> 통과할 수 없는 라운드 - 1
3. 즉 최대 `left`를 구한 뒤 `left - 1`을 반환. 이때 `left<=right`인 동안 반복. (ex. `left = 3`, `right = 3` 인 경우, 2라운드는 통과했으나 4라운드는 통과하지 못했다는 의미이다. 이때 3라운드의 통과 가능 여부를 모르기 때문에 `check(3)`의 확인이 필요하다.)
4. `check(round)` 함수는 해당 라운드의 통과 가능 여부를 불리언으로 반환.
   4-1. `round`까지의 적 배열을 잘라 오름차순 정렬.

   4-2. 적 && [무적권]이 남아 있는 동안 적이 많은 순서대로 [무적권] 사용.

   4-3. 1번에서 구한 누적 적의 수에서, [무적권] 사용 라운드의 적의 수만큼 뺀 값이 필요한 병사 수이다.

   4-4. 이 병사 수보다 가진 병사 수가 같거나 크면 라운드 통과가 가능.

5. `mid` 라운드까지 통과 가능하다면 `left = mid + 1`, 불가하다면 `right = mid - 1`
