# 1. 문제 파악

## 1-1. 주어진 정보

- `scoville`: 스코빌 지수 배열 (1~100만, 원소 0~100만)
- `K`: 모든 스코빌 지수를 `K` 이상이 되도록 만들어야 한다 (0~10억)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/42626

# 2. 내 풀이

## 2-1. 알고리즘

- 100만 \* 100만 \* log(100만) -> 시간초과
- 우선순위 큐

## 2-2. 시간복잡도

- `O(NlogN)` (`N`=100만)

## 2-3. 풀이

```js
class MinHeap {
  constructor() {
    // 0번 인덱스를 넣어서 인덱스 계산을 편하게 한다.
    // 문제에서 음수와 양수가 섞여있지 않기 때문에, 항상 null이 0번 인덱스가 되어 힙 구현에 문제가 없다.
    this.heap = [null];
  }

  #swap(a, b) {
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }


  size() {
    // 0번 인덱스인 null을 제외
    return this.heap.length - 1;
  }

  heap_push(value) {
    // 1. 가장 뒤에 push
    this.heap.push(value);

    // 2. 부모노드와 비교하며 작다면 부모노드와 swap
    // 3. 부모노드와 현재 노드 인덱스도 swap
    // 4. 부모보다 현재 노드가 더 작은 동안 진행. (최소 힙이므로 작은 노드를 위로 올려야 함)
    let curIdx = this.size();
    let parentIdx = Math.floor(curIdx / 2);
    while (this.heap[curIdx] < this.heap[parentIdx]) {
      this.#swap(curIdx, parentIdx);

      curIdx = parentIdx;
      parentIdx = Math.floor(curIdx / 2);
    }
  }

  heap_pop() {
    if (!this.size()) {
      return null;
    }
    if (this.size() === 1) {
      return this.heap.pop();
    }

    // 1. 가장 끝 노드와 swap
    this.#swap(1, this.size());

    // 2. 가장 끝 노드 없애기
    const value = this.heap.pop();

    // 3. 왼쪽 / 오른쪽 자식과 비교 후 현재 노드가 더 크면 swap
    // 자식이 없을 수 있음 주의
    let curIdx = 1;
    let leftChildIdx = curIdx * 2;
    let rightChildIdx = curIdx * 2 + 1;
    while (
      (this.heap[leftChildIdx] &&
        this.heap[curIdx] > this.heap[leftChildIdx]) ||
      (this.heap[rightChildIdx] && this.heap[curIdx] > this.heap[rightChildIdx])
    ) {
      // 3-1. 왼쪽과 오른쪽 자식 중 더 작은 값의 인덱스 찾기
      // 왼쪽 자식부터 채우므로 오른쪽 자식이 없을 수 있음 주의
      const smallIdx =
        this.heap[rightChildIdx] &&
        this.heap[leftChildIdx] > this.heap[rightChildIdx]
          ? rightChildIdx
          : leftChildIdx;
      // 3-2. 비교 후 현재 인덱스의 값이 더 크면 swap
      // 4. 현재 노드가 자식보다 더 큰 동안 진행. (최소 힙이므로 큰 노드를 밑으로 내려야 함)
      if (this.heap[curIdx] > this.heap[smallIdx]) {
        this.#swap(curIdx, smallIdx);
        curIdx = smallIdx;
      }

      leftChildIdx = curIdx * 2;
      rightChildIdx = curIdx * 2 + 1;
    }

    return value;
  }

  top() {
    if (!this.size()) {
      return null;
    }
    return this.heap[1];
  }
}

function solution(scoville, K) {
  const heap = new MinHeap();
  scoville.forEach((item) =>
    heap.heap_push(item);
);

  let count = 0;
  while (heap.top() < K) {
    if (heap.size() === 1) {
      return -1;
    }
    const a = heap.heap_pop();
    const b = heap.heap_pop() * 2;
    heap.heap_push(a + b);

    count++;
  }
  return count;
}
```

1. 모든 스코빌 지수 최소 힙에 담기
2. 스코빌 지수의 최소값이 `K`보다 작은 동안 진행. 최소값이 `K` 이상이라면 모든 스코빌 지수가 `K` 이상이기 때문
3. 음식을 모두 섞어 최소 힙의 크기가 1이 되었음에도 while문 안에 있다면 스코빌 지수를 `K` 이상으로 만들지 못했으므로 -1 반환
4. 가장 맵지 않은 음식의 스코빌 지수 `a`, 두번째로 맵지 않은 음식의 스코빌 지수 \* 2 `b`를 더해 최소 힙에 다시 담기
5. 섞은 횟수 `count` 증가
6. 반복문 종료 후 `count` 반환
