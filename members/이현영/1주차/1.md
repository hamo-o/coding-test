# 1. 문제 파악

## 1-1. 주어진 정보

- `maps`: 미로 2차원 배열 (100\*100)

## 1-2. 문제 링크

https://school.programmers.co.kr/learn/courses/30/lessons/159993

# 2. 내 풀이

## 2-1. 알고리즘

- 미로를 빠져나가기 위한 "최단거리" -> BFS
- 시작점 ~ 레버 + 레버 ~ 출구

## 2-2. 시간복잡도

## 2-3. 풀이

```js
function solution(maps) {
  const n = maps.length;
  const m = maps[0].length;
  const d = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1],
  ];
  const points = {
    start: [],
    mid: [],
    end: [],
  };

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      if (maps[i][j] === "S") points.start = [i, j];
      else if (maps[i][j] === "L") points.mid = [i, j];
      else if (maps[i][j] === "E") points.end = [i, j];
    }
  }

  const s_to_l = bfs(points.start, points.mid);
  if (s_to_l === -1) return -1;
  const l_to_e = bfs(points.mid, points.end);
  if (l_to_e === -1) return -1;

  return s_to_l + l_to_e;

  function bfs([sx, sy], [ex, ey]) {
    const visited = new Array(n).fill(0).map(() => new Array(m).fill(0));
    const queue = [];
    visited[sx][sy] = 1;
    queue.push([sx, sy]);

    let front = 0;
    while (front < queue.length) {
      const [x, y] = queue[front];
      front++;

      for (const [dx, dy] of d) {
        if (
          x + dx >= 0 &&
          x + dx < n &&
          y + dy >= 0 &&
          y + dy < m &&
          !visited[x + dx][y + dy] &&
          maps[x + dx][y + dy] !== "X"
        ) {
          visited[x + dx][y + dy] = visited[x][y] + 1;
          queue.push([x + dx, y + dy]);
          if (x + dx === ex && y + dy === ey) return visited[ex][ey] - 1;
        }
      }
    }

    return -1;
  }
}
```

1. `map` 전체를 순회하면서, 시작점 `S`, 중간지점 `L` (레버를 무조건 당겨야 탈출가능), 끝지점 `E`를 저장
2. 시작 ~ 중간 `bfs` 수행. 이때 중간지점까지 도달하지 못했으면 `-1` 반환
3. 중간 ~ 끝 `bfs` 수행. 이때 끝지점까지 도달하지 못했으면 `-1` 반환
4. 2번과 3번의 결과를 더해서 반환
5. `bfs` 내부 로직

   5-1. 방문했던 곳을 다시 방문하면 최단거리가 될 수 없으므로, 방문체크를 해주기 위한 `visited` 배열 생성

   5-2. 시작점을 `queue`에 넣어주고 시작.

   5-3. 다음 좌표가 `map`을 벗어나지 않고, 아직 방문하지 않았으며, `X`가 아니라면 방문한다.

   5-4. `visited`에는 `직전 값 + 1`을 담아 최단거리를 알 수 있도록 한다.

   5-5. 목표 위치에 도달했으면 `visited[목표위치] - 1`의 값을 반환한다. 처음 위치는 거리에 포함되지 않기 때문이다.
